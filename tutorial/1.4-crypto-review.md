# Cryptographic Primitives

Before we dig into the Noise Protocol and become cypherpunks ourselves, it's important that we review some of the cryptographic primitives that make the Noise Protocol possible. If you're already familiar with these, feel free to skip ahead!

## Public Keys
In elliptic curve cryptography, **public keys** are simply points on the elliptic curve! This means they can be represented as **(x, y) coordinates**. In the visual below, you'll see a simplified visual that is meant to represent the secp256k1 elliptic curve, which is the flavor of elliptic curve that bitcoin uses. Keep in mind, in reality, the curve would look more like a scatter plot, since the secp256k1 is actually over a finite field, but those details are outside the scope of this article. If you'd like to learn more, [learn me a bitcoin](https://learnmeabitcoin.com/technical/keys/public-key/), as always, has a fantastic resource.

Now, once you have the (x, y) coordinate, where each component can be represented as a 32 byte (256 bit) integer (it's a really large number), you have a few options for how you'd like to format this public key point.

#### Uncompressed Public Key
One option is to simply list the full x and y coordinates.
```
04 79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
```
- `04`: This is the **Prefix**. `04` means this public key is in uncompressed format.

#### Compressed Public Key
Another option is to use the compressed format. Since secp256k1 elliptic curve is symmetrical around the x axis, there are only two possible y coordinates - an even and odd one. Therefore, an easy and effective way to save ~50% of space is to replace the y coordinate with a **parity byte**, which is a 1-byte representation of whether the y coordinate is even or odd. A parity byte of `02` means the y coordinate is even, while a parity byte of `03` means the y coordinate is odd.

In the example below, you'll see we use a parity byte of `02`, meaning the y coordinate is even. Then, we simply provide the x coordinate.

```
02 79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
``` 

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/public_key_serialization.png" alt="public_key_serialization" width="100%" height="auto">
</p>

#### Fun Fact! The public key listed above is actually the "Generator Point" for the secp256k1 curve.
The **Generator Point** is a publically agreed upon point on the secp256k1 curve, which everyone can use to derive a public key. For example, imagine you had a private key, which is simply a very large (256-bit) number. You can derive a public key for that private key by multiplying the large number by the Generator Point, `G`.

```
Public Key = private key × G
```


## Hash Functions
Ahh, hash functions! Chances are you've heard of them before - they are probably the most popular cryptographic primitive that we'll review, and they are a major building block to many of the advanced cryptographic tools we'll review later.

A hash function is relatively simple to explain (at a high level). It takes an input of arbitrary length and produces a random output. Crucially, hash functions have the following properties, which make them quite useful to build secure protocols on top of.
- **One-Way**: Hash functions are *one-way* functions. This means that it's easy to calculate a hash, given an input. However, it's incredily difficult (effectively impossible) to calculate the input, given the output. In technical terms, this is called "pre-image resistance" because you cannot calculate the input (called a "pre-image") given the output.
- **Collision Resistant**: The second important property is collision resistance. This means that it is extremely hard (again, practically impossible) to find two *different* inputs that have the *same* output. In other words, going off the above example, two different public keys should not ever hash to the same output value.
- **Deterministic**: The third property is determinism. Each unique input will produce the same unique output - every time! In other words, if we were to hash the public key above 1 million times (or more), it will always produce the same output with a fixed length, defined by the choice of hash function.

The Lightning Network makes heavy use of **SHA256** hash function. This algorithm, called the Secure Hash Algorithm, is part of the SHA-2 family and produces a 256-bit (32 byte) output every time.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/sha256.png" alt="sha256" width="100%" height="auto">
</p>

## Elliptic Curve Diffie-Hellman
Now that we're armed with our knowledge of public keys and hash functions, we can put them together and start building pretty useful cryptography. We'll begin our journey by exploring the Elliptic Curve Diffie-Hellman protocol. But, first - some history! In the 1970s, the field of modern cryptography was beggining to blossom in two very different settings. On one hand, the National Security Agency (NSA) was developing cryptography in secret, with the hopes of spying on both US citizens and foreners alike to, as always, catch "criminals". On the other hand, a group of academics and "cypherpunks" were rapidly discovering cryptography themselves. One such duo was Whit Diffie, an MIT graduate who became fascinated with the nascent field of cryptography after graduating, and Martin Hellman, an electrical engineering PhD from Stanford who worked at IBM before joining Stanford's faculty to study cryptography.

A central question that plagued Whit and Martin was this: **Without a trusted third party, how could two people, who had never met before, create a shared secret over an insecure channel**? Up until this point, all *publically-known* (remember, the NSA did not like to share their research) cryptography was symmetric-key cryptography - meaning both parties needed to share the same secret key to encrypt and decrpyt messages. However, one day, Whitt had an insight that blew a hole through this notion - why not make one of the keys public? This insight, which opened the door to public-key cryptography, led to the development of the Diffie-Hellman (DH) protocol, which was originally based on modular arithmetic. Later, this protocol was adapted to use elliptic curves instead of modular arithmetic, leading to the protocol used today in the Noise Framework: Elliptic Curve Diffie-Hellman (ECDH).

As always, let's introduce Alice and Bob our example. Imagine Alice wants to communicate with Bob privately, but Alice does not have a secure channel with Bob. A **secure channel** is one where Alice can be sure she is truly talking to Bob and that nobody else is listening or tampering with their communcation. For instance, imagine a private, in-person conversation on a hike in the middle of a forrest. If Alice and Bob had a secure channel, they could simply come up with a **shared secret** - a hidden piece of information that only they know - which they can use to *encrypt* and *decrypt* information. However, with no secure channel, what are they supposed to do?

Well, Whit Diffie and Martin Hellman had an answer. Alice and Bob use their private keys and each generate a public key. Since the public key is meant to be... public, they are safe to share this over an insecure channel, such as a plain TCP connection. Alice and Bob can then generate a **shared secret** by multiplying their private key by the other person's public key, creating an entirely new point on the curve. Crucially, due to the associative and commutativity property of elliptic curve mathematics, they will each calculate the exact same result! They can then, independently, represent the point in it's condensed format and take the SHA256 hash of it, which will produce the exact same 32-byte secret for each of them. This secret becomes a **shared secret**, since only they know it. During this entire protocol, the only information they ever share over the insecure channel is their public keys, which are safe to be publicized anyway.


<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/ecdh.png" alt="ecdh" width="100%" height="auto">
</p>

```
Shared Secret Calculation:
  Alice computes: a × B = a × (b × G) = (a × b) × G
  Bob computes:   b × A = b × (a × G) = (b × a) × G

Both Alice and Bob get the same point! (a × b) × G = (b × a) × G
```

## Hash-Based Key Derivation

Moving on, let's introduce the next cryptographic tool we'll be using later in our journey - **Hash-Based Key Derivation**. At this point in our cryptography overview, Alice and Bob have created **one** shared secret. However, Alice and Bob will need additional secrets as well, which will be used to authenticate their connection and ensure the integrity of their messages. To do this, they'll use a **Key Derivation Function**, which allows them to create multiple secrets from one.

For Lightning's implementation of the Noise Protocol, the **HMAC-based Key Derivation Function (HKDF)** is used. HKDF is a two-phase key derivation function - defined in [RFC 5869](https://www.rfc-editor.org/rfc/rfc5869) - that expands an input into an arbitrary length, uniformly random output. HKDF consists of the following two phases:

- **HKDF-Extract**: In the extract phase, the function removes any bias that may be present in the input and produces a pseudorandom key. The extract function takes an additional input, `salt`. Salt is an optional parameter (default = all-zero byte string) that can be used to provide domain separation or context for the derivation.

- **HKDF-Expand**: The expand phase takes the pseudorandom output from the extract phase and expands it to the desired length. This function takes two parameters: `info` and `output length`. The info parameter, similar to salt, allows for domain separation if your protocol uses HKDF-Expand in multiple contexts. The output length parameter allows the implementer to specify the length of the output. Since Lightning uses HKDF to expand one secret into two and does not need explicit domain separation via the info parameter, it uses the default value of an empty string for info and specifies 64 bytes for the output length, which can then be split into two 32-byte keys.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/HKDF.png" alt="HKDF" width="70%" height="auto">
</p>

## ChaCha20-Poly1305

## Noise Protocol Framework

The Noise Protocol is a **secure channel** protocol, meaning that data tranmitted over this channel is resistant to outsiders eavesdropping and tampering with the content being transfered. If we were to map this definition onto Lightning, it means that, if Alice and Bob are communicating with each other, nobody else should be able to read the content of their messages or change the content itself. It's easy to see why this is crucial for a payment protocol. First, payments are private information and nobody elses business! Second, if anyone could alter data messages in transit, they could easily change the amount of money being sent in any given transaction. That would be... bad!

It's also worth noting that Lightning is in good company when it comes to choosing the Noise Protocol. For instance, popular messaging platforms such as WhatsApp and Slack also leverage the Noise Framework to add end-to-end encryption for their 3+ billion users!

Up next, we'll dig very deep into the Noise Protocol and even implement part of it ourselves! However, before doing that, let's introduce a few important security properties that the Noise Protocol will provide for Lightning.

### Mutual Authentication & Identity Hiding


### Encryption

### Forward Secrecy


The Noise Protocol is built around channel partners creating a **shared secret** - which is a piece of data that only the two partners know - by using Diffie–Hellman key exchange. This shared secret can then be used to achieve certain privacy nd security requirements, such as **mutual authentication**, **forward secrecy**, and **identity protection**. We'll review each of these in more detail shortly!
