# Cryptographic Primitives

Before we dig into the Noise Protocol and become cypherpunks ourselves, it's important that we review some of the cryptographic primitives that make the Noise Protocol possible. If you're already familiar with these, feel free to skip ahead!

# Public Keys
In elliptic curve cryptography, **public keys** are simply points on the elliptic curve! This means they can be represented as **(x, y) coordinates**. In the visual below, you'll see a simplified visual that is meant to represent the secp256k1 elliptic curve, which is the flavor of elliptic curve that bitcoin uses. Keep in mind, in reality, the curve would look more like a scatter plot, since the secp256k1 is actually over a finite field, but those details are outside the scope of this article. If you'd like to learn more, [learn me a bitcoin](https://learnmeabitcoin.com/technical/keys/public-key/), as always, has a fantastic resource.

Now, once you have the (x, y) coordinate, where each component can be represented as a 32 byte (256 bit) integer (it's a really large number), you have a few options for how you'd like to format this public key point.

#### Uncompressed Public Key
One option is to simply list the full x and y coordinates.
```
04 79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
```
- `04`: This is the **Prefix**. `04` means this public key is in uncompressed format.

#### Compressed Public Key
Another option is to use the compressed format. Since secp256k1 elliptic curve is symmetrical around the x axis, there are only two possible y coordinates - an even and odd one. Therefore, an easy and effective way to save ~50% of space is to replace the y coordinate with a **parity byte**, which is a 1-byte representation of whether the y coordinate is even or odd. A parity byte of `02` means the y coordinate is even, while a parity byte of `03` means the y coordinate is odd.

In the example below, you'll see we use a parity byte of `02`, meaning the y coordinate is even. Then, we simply provide the x coordinate.

```
02 79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
``` 

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/public_key_serialization.png" alt="public_key_serialization" width="100%" height="auto">
</p>

#### Fun Fact! The public key listed above is actually the "Generator Point" for the secp256k1 curve.
The **Generator Point** is a publically agreed upon point on the secp256k1 curve, which everyone can use to derive a public key. For example, imagine you had a private key, which is simply a very large (256-bit) number. You can derive a public key for that private key by multiplying the large number by the Generator Point, `G`.

```
Public Key = private key × G
```


# Hash Functions
Ahh, hash functions! Chances are you've heard of them before - they are probably the most popular cryptographic primitive that we'll review, and they are a major building block to many of the advanced cryptographic tools we'll review later.

A hash function is relatively simple to explain (at a high level). It takes an input of arbitrary length and produces a random output. Crucially, hash functions have the following properties, which make them quite useful to build secure protocols on top of.
- **One-Way**: Hash functions are *one-way* functions. This means that it's easy to calculate a hash, given an input. However, it's incredily difficult (effectively impossible) to calculate the input, given the output. In technical terms, this is called "pre-image resistance" because you cannot calculate the input (called a "pre-image") given the output.
- **Collision Resistant**: The second important property is collision resistance. This means that it is extremely hard (again, practically impossible) to find two *different* inputs that have the *same* output. In other words, going off the above example, two different public keys should not ever hash to the same output value.
- **Deterministic**: The third property is determinism. Each unique input will produce the same unique output - every time! In other words, if we were to hash the public key above 1 million times (or more), it will always produce the same output with a fixed length, defined by the choice of hash function.

The Lightning Network makes heavy use of **SHA256** hash function. This algorithm, called the Secure Hash Algorithm, is part of the SHA-2 family and produces a 256-bit (32 byte) output every time.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/sha256.png" alt="sha256" width="100%" height="auto">
</p>

# Elliptic Curve Diffie-Hellman
Now that we're armed with our knowledge of public keys and hash functions, we can put them together and start building pretty useful cryptography. We'll begin our journey by exploring the Elliptic Curve Diffie-Hellman protocol. But, first - some history! In the 1970s, the field of modern cryptography was beggining to blossom in two very different settings. On one hand, the National Security Agency (NSA) was developing cryptography in secret, with the hopes of spying on both US citizens and foreners alike to, as always, catch "criminals". On the other hand, a group of academics and "cypherpunks" were rapidly discovering cryptography themselves. One such duo was Whit Diffie, an MIT graduate who became fascinated with the nascent field of cryptography after graduating, and Martin Hellman, an electrical engineering PhD from Stanford who worked at IBM before joining Stanford's faculty to study cryptography.

A central question that plagued Whit and Martin was this: **Without a trusted third party, how could two people, who had never met before, create a shared secret over an insecure channel**? Up until this point, all *publically-known* (remember, the NSA did not like to share their research) cryptography was symmetric-key cryptography - meaning both parties needed to share the same secret key to encrypt and decrpyt messages. However, one day, Whitt had an insight that blew a hole through this notion - why not make one of the keys public? This insight, which opened the door to public-key cryptography, led to the development of the Diffie-Hellman (DH) protocol, which was originally based on modular arithmetic. Later, this protocol was adapted to use elliptic curves instead of modular arithmetic, leading to the protocol used today in the Noise Framework: Elliptic Curve Diffie-Hellman (ECDH).

As always, let's introduce Alice and Bob our example. Imagine Alice wants to communicate with Bob privately, but Alice does not have a secure channel with Bob. A **secure channel** is one where Alice can be sure she is truly talking to Bob and that nobody else is listening or tampering with their communcation. For instance, imagine a private, in-person conversation on a hike in the middle of a forrest. If Alice and Bob had a secure channel, they could simply come up with a **shared secret** - a hidden piece of information that only they know - which they can use to *encrypt* and *decrypt* information. However, with no secure channel, what are they supposed to do?

Well, Whit Diffie and Martin Hellman had an answer. Alice and Bob use their private keys and each generate a public key. Since the public key is meant to be... public, they are safe to share this over an insecure channel, such as a plain TCP connection. Alice and Bob can then generate a **shared secret** by multiplying their private key by the other person's public key, creating an entirely new point on the curve. Crucially, due to the associative and commutativity property of elliptic curve mathematics, they will each calculate the exact same result! They can then, independently, represent the point in it's condensed format and take the SHA256 hash of it, which will produce the exact same 32-byte secret for each of them. This secret becomes a **shared secret**, since only they know it. During this entire protocol, the only information they ever share over the insecure channel is their public keys, which are safe to be publicized anyway.


<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/ecdh.png" alt="ecdh" width="100%" height="auto">
</p>

```
Shared Secret Calculation:
  Alice computes: a × B = a × (b × G) = (a × b) × G
  Bob computes:   b × A = b × (a × G) = (b × a) × G

Both Alice and Bob get the same point! (a × b) × G = (b × a) × G
```

# Hash-Based Key Derivation

Moving on, let's introduce the next cryptographic tool we'll be using later in our journey - **Hash-Based Key Derivation**. At this point in our cryptography overview, Alice and Bob have created **one** shared secret. However, Alice and Bob will need additional secrets as well, which will be used to authenticate their connection and ensure the integrity of their messages. To do this, they'll use a **Key Derivation Function**, which allows them to create multiple secrets from one.

For Lightning's implementation of the Noise Protocol, the **HMAC-based Key Derivation Function (HKDF)** is used. HKDF is a two-phase key derivation function - defined in [RFC 5869](https://www.rfc-editor.org/rfc/rfc5869) - that expands an input into an arbitrary length, uniformly random output. HKDF consists of the following two phases:

- **HKDF-Extract**: In the extract phase, the function removes any bias that may be present in the input and produces a pseudorandom key. The extract function takes an additional input, `salt`. Salt is an optional parameter (default = all-zero byte string) that can be used to provide domain separation or context for the derivation.

- **HKDF-Expand**: The expand phase takes the pseudorandom output from the extract phase and expands it to the desired length. This function takes two parameters: `info` and `output length`. The info parameter, similar to salt, allows for domain separation if your protocol uses HKDF-Expand in multiple contexts. The output length parameter allows the implementer to specify the length of the output. Since Lightning uses HKDF to expand one secret into two and does not need explicit domain separation via the info parameter, it uses the default value of an empty string for info and specifies 64 bytes for the output length, which can then be split into two 32-byte keys.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/HKDF.png" alt="HKDF" width="70%" height="auto">
</p>

# ChaCha20-Poly1305
So far, we've covered the cryptographic building blocks that allow Alice and Bob to establish a shared secret (ECDH) and derive multiple keys (HKDF). However, even with these complex tools, they are still unable to establish a secure channel. To do that, we'll need a way for Alice and Bob to achieve the following:
- **Confidentiality**: Alice and Bob's messages should be encrypted such that only they can read them.
- **Integrity**: When Alice receives a message from Bob (and vice versa), she should be able to detect if anyone tampered or changed it.
- **Authentication**: Alice and Bob should be able to verify that the messages in their secure channel truly originated from them.

The ChaCha20-Poly1305 algorithm, defined in [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439), is an "all-in-one" algorithm that provides both encryption and authentication. More generally, it is one example of a class of all-in-one constructions calls **Authenticated Encryption with Associated Data (AEAD)**. Researchers have trended towards these all-in-one algorithms because using encryption without integrity or authentication could be quite dangerous. For instance, consider the classic scenario below...

Imagine Alice wants to send Bob an encrypted message, informing him how much money he should donate to charity (Bob is a nice guy, after all). So, Alice takes her message, encrypts it with their shared secret, and sends it over. BUT, an attacker - who somehow knows the format of her message - decides to change just 1 tiny byte, which ultimately alters the message that Bob receives. Now, instead of donating $100, Bob donates $900! A morally complicated outcome, indeed.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/integrity.png" alt="integrity" width="100%" height="auto">
</p>

To mitigate the above **malleability attack**, as well as other forms of attack, developers will opt for all-in-one solution that simplifies the implemenation and provides encryption, integrity, and authentication all in one.

Now that we have some background intuition for *why* we need something like an AEAD algorithm, let's briefly review how ChaCha20-Poly1305 works.

## ChaCha20
As we just learned, ChaCha20-Poly1305 is an all-in-one construction, so it naturally involves more than one algorithm.

The first algorithm, ChaCha20, is a stream cipher, and it's job is to create a pseudorandom keystream that can be XORed with the plaintext or ciphertext to produce the ciphertext or plaintext, respectfully. The ChaCha20 algorithm takes the following two inputs:
- **Key**: A 32-byte (256-bit) secret key. For example, Alice and Bob can use their shared secret (or an HKDF-derivation of it) as a symmetrical key, which they can use to encrypt/decrypt messages to each other.
- **Nonce**: A 12-byte (96-bit) "number used once", which must be unique for each message. This ensure that, if you encrypt the same message multiple times, you'll always get different ciphertexts.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/chacha20.png" alt="chacha20" width="70%" height="auto">
</p>


#### Question: Why is nonce reuse bad? What attack vectors are exposed if you reuse a nonce?
<details>
  <summary>Answer</summary>
  
A **nonce**, or "number used once," is a critical component for generating a *unique* keystream. If you use the same nonce and key, the resulting keystream will be identical, opening you up to attack vectors from bad actors!

For instance, consider the example in the diagram below. Imagine that Alice and Bob are freedom fighters planning a revolution! Alice, the budding cypherpunk, uses ChaCha20 to encrypt her first message to Bob: `4RESISTANCE`. To do this, she uses a shared secret and sets the nonce to `0`.

Now, Alice wants to send Bob another message with information about when the freedom fighters plan to meet next: `MEETATSUNUP`. Unfortunately, Alice uses the same shared secret and nonce for this message!

Little did Alice and Bob know, but there is an attacker listening in on the conversation, and he now has access to both ciphertexts! He can XOR these ciphertexts together and examine the results. If there is a `00` byte in the XOR result, that means both *plaintexts* have the same character at that position! The attacker can exploit this information through frequency analysis and statistical techniques. If the attacker can guess or know even one of the plaintexts (or parts of it), they can recover the other plaintext entirely. Even worse, once they recover a plaintext, they can XOR it with its ciphertext to learn the keystream and decrypt all future messages using the same nonce!

To prevent this, Alice must simply increment the nonce with each message to produce a completely different keystream every time.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/nonce_reuse.png" alt="nonce_reuse" width="70%" height="auto">
</p>

</details>

## Poly1305

Great, so we've seen how Alice and Bob can use ChaCha20 to encrypt a message, but we're not in the clear yet! They still need to be able to *authenticate* their messages, ensuring that the message has not been tampered with during transit. To do this, we'll use Poly1305, which is a type of **Message Authentication Code (MAC)**. MAC algorithms, generally, produce **authentication tags**, which are effectively cryptographic stamps that are specific to each message. To create the tag, the sender uses the shared secret to calculate a hash specific to their message, which the recipient can also verify with the shared secret. Since the shared secret is only known by the sender and receiver, the receiver is able to verify that the message truly came from the sender - authenticating the sender - and that the message content did not change - ensuring its integrity.

Poly1305 is a MAC algorithm, and when combined with ChaCha20 in the **ChaCha20-Poly1305 AEAD construction**, it supports **associated data** - data that is *not* encrypted but is still authenticated by the tag, ensuring the recipient can verify its integrity. For example, imagine the header of a network packet - the routing information might need to be readable by intermediaries (so it can't be encrypted), but the sender still wants to ensure it cannot be altered in transit. By including this header as associated data, any tampering with it will cause the authentication tag to fail.

Poly1305 takes the following parameters:

- **Associated Data**: Additional data that should be authenticated but not encrypted (like headers or metadata).
- **Ciphertext**: An encrypted message output. In our case, it comes from ChaCha20 encryption.
- **Len(Ciphertext)**: The length of the ciphertext in bytes.
- **Len(Associated Data)**: The length of the associated data in bytes.
- **r (Authentication Key)**: A 16-byte key derived from the shared secret.
- **s (Secret Key)**: A 16-byte key derived from the shared secret, used to finalize the tag.

> **NOTE**: The Associated Data, Ciphertext, Len(Ciphertext), and Len(Associated Data) are concatenated before being input into the Poly1305 algorithm.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/poly1305.png" alt="poly1305" width="100%" height="auto">
</p>

## Combining ChaCha20 & Poly1305

Now that we understand both ChaCha20 and Poly1305 individually, let's see how they work together in the ChaCha20-Poly1305 AEAD construction. Remember, by using this all-in-one construction, Alice and Bob not only encrypt their messages, but they are able to *authenticate* and *verify the integrity* of each message.

The ChaCha20-Poly1305 algorithm takes the following inputs:

- **Plaintext**: The message Alice wants to send to Bob.
- **Associated Data**: Any additional data that needs authentication but not encryption (like packet headers)
- **Key**: The 32-byte shared secret derived from ECDH and HKDF
- **Nonce**: The 12-byte "number used once" that ensures each encryption is unique

Once the inputs are provided, ChaCha20-Poly1305 performs a little bit of magic. The diagram below, which is an adaptation of the ChaCha20-Poly1305 diagram from the textbook [Real World Cryptography](https://www.manning.com/books/real-world-cryptography), explains, roughly, what's going on.

Under the hood, the ChaCha20 algorithm is run multiple times. First, the algorithm will take the provided **key** and **nonce** and generate a 64-byte keystream block. The first 16 bytes are extracted and used as the **r** key for Poly1305. The next 16 bytes are extracted and used as the **s** key for Poly1305. The remaining 32 bytes are discarded.

You'll likely notice that there is a new variable - **counter**! The counter starts at 0 and increments with each 64-byte keystream block that ChaCha20 generates. This allows ChaCha20 to encrypt messages of any length by generating as many keystream blocks as needed. The **nonce** remains constant throughout encrypting a single message (changing only between different messages), while the **counter** increments within a message to ensure each block of keystream is unique.

This is why, in the next block, the counter increments to 1, and ChaCha20 generates a new 64-byte keystream block. This keystream is XORed with the **plaintext** to produce the **ciphertext**. If the plaintext is longer than 64 bytes, the counter continues incrementing (2, 3, 4...) to generate additional keystream blocks as needed.

Once we have our ciphertext, we concatenate it with the associated data (which is *not* encrypted) along with their lengths, and feed this into Poly1305 with the **r** and **s** keys. Finally, the ChaCha20-Poly1305 construction outputs the **ciphertext** concatenated with the **authentication tag** produced by Poly1305.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/chacha20_poly1305.png" alt="chacha20_poly1305" width="100%" height="auto">
</p>


## Noise Protocol Framework

The Noise Protocol is a **secure channel** protocol, meaning that data tranmitted over this channel is resistant to outsiders eavesdropping and tampering with the content being transfered. If we were to map this definition onto Lightning, it means that, if Alice and Bob are communicating with each other, nobody else should be able to read the content of their messages or change the content itself. It's easy to see why this is crucial for a payment protocol. First, payments are private information and nobody elses business! Second, if anyone could alter data messages in transit, they could easily change the amount of money being sent in any given transaction. That would be... bad!

It's also worth noting that Lightning is in good company when it comes to choosing the Noise Protocol. For instance, popular messaging platforms such as WhatsApp and Slack also leverage the Noise Framework to add end-to-end encryption for their 3+ billion users!

Up next, we'll dig very deep into the Noise Protocol and even implement part of it ourselves! However, before doing that, let's introduce a few important security properties that the Noise Protocol will provide for Lightning.

### Mutual Authentication & Identity Hiding


### Encryption

### Forward Secrecy


The Noise Protocol is built around channel partners creating a **shared secret** - which is a piece of data that only the two partners know - by using Diffie–Hellman key exchange. This shared secret can then be used to achieve certain privacy nd security requirements, such as **mutual authentication**, **forward secrecy**, and **identity protection**. We'll review each of these in more detail shortly!
