# Noise Protocol: Act 1

Now that Alice has her pre-handshake state, she is ready to connect to Bob! In the "real world", Bob will compute his pre-handshake state when receiving the inbound connection from Alice.

The first act of the Noise handshake protocol is Alice answering an implicit *challenge* from Bob: **prove you know Bob's public key**. We refer to it as a "challenge" because it follows the popular cryptographic **challenge-response pattern**, whereby one party satisfies a challenge, proving they know something, and then the other party responds.

In this case, Act 1 is about Alice proving she knows who Bob is without actually sending his public key across the wire. To do this, she will mix Bob's public key into her handshake hash, which is then used in the Message Authentication Code (MAC), enabling Bob to verify the challenge privately. Let's see how it's done!

## Act 1: Alice's Point-of-View

<p align="left" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/noise_act1_alice.png" alt="noise_act1_alice" width="100%" height="auto">
</p>

### Step 1: Alice Generates Ephemeral Key Pair
Alice's first step is to create an **Ephemeral Public and Private Key Pair**. At this point, you may be wondering: "Why does Alice need an ephemeral key pair? She has her own public and private keys!" That would be a fantastic question, and we'll answer it in Step 3!

### Step 2: Alice Mixes Ephemeral Public Key into Handshake Hash
Next, Alice will mix the **Ephemeral Public Key** into the **Handshake Hash**. Remember, this was initialized in the Handshake Setup stage, and it will serve as a shared session state, allowing both Alice and Bob to independently verify they are in sync as they move through each act in the handshake.

### Step 3: Alice Computes ECDH Shared Secret
Here's where the magic begins to happen! Alice will create an Elliptic Curve Diffie-Hellman (ECDH) shared secret using *her* **Ephemeral Private Key** and *Bob's* **Static Public Key**. If you'd like a brief review of the ECDH operation, head back to the Cryptographic Primitives section!

#### Question: Why does Alice use her Ephemeral Public Key and not her Static Public Key?
> HINT: This will become more clear after reading through Step 7! If you'd like, come back to this question after reading all of Alice's steps for Act 1.

<details>
  <summary>Answer</summary>

Remember, Alice's Static Public Key is her Lightning node identity. If she sent it in plaintext in Act 1, any eavesdropper monitoring the network would immediately know who is connecting to Bob. However, Alice must send Bob *some* public key so that he can compute a shared secret - one of the main goals of the Noise Handshake.

By using an Ephemeral Public Key instead, Alice can send a public key that enables ECDH while keeping her true identity hidden. This is where the `XK` in Lightning's Noise handshake pattern comes in! The `X` means Alice, the initiator, transmits her identity in encrypted form so it remains hidden from eavesdroppers. As we'll see later, once the shared secret is established, Alice will be able to safely send her Static Public Key encrypted so that others cannot read it.

</details>

### Step 4: Alice Derives Temporary Encryption Key
Once Alice has the ECDH shared secret, `es`, she will input the shared secret and the **Chaining Key** (from the Handshake Setup) into the Hash-based Key Derivation Function, deriving the following two keys:
- **Chaining Key** (`ck`): The Chaining Key will be a *chain* of ECDH secrets that are derived during the handshake phase. Alice and Bob will use the `ck` to derive the encryption keys for their Lightning messages. 
- **Temporary Key 1** (`temp_k1`): This will be our single-use key that we can use to create an Message Authentication Code for our message before we send it to Bob. If you remember from the Cryptographic Primitives section, we'll use ChaCha20-Poly1305 to both encrypt and authenticate our message to Bob so that he can validate it has not been altered during transit.


### Step 5: Alice Creates an Authentication MAC
Okay, this is an important step! Before digging in, let's recap what Alice has done:
1. She created an Ephemeral Public and Private Key.
2. She mixed the Ephemeral Public Key into the Handshake Hash to update the session state.
3. She used the Ephemeral Public Key to create an ECDH shared secret with Bob's Static Public Key, which she knew *before* connecting to Bob.
4. She derived a new Temporary Key and updated the Chaining Key.

Remember, the goal of Act 1 is to prove to Bob that she knows his public key without revealing her identity in plain text. To do this, she just needs to send the shared secret to Bob, but she will need to make sure Bob can authenticate the message, trusting that it was not tampered with during transit. Luckily, we have just the function to do that: ChaCha20-Poly1305!

In Step 5, Alice will use ChaCha20-Poly1305 to authenticate and encrypt her message. The following inputs are passed into the algorithm:

- **Plaintext**: There is not plaintext to encrypt, so this is left blank for now with a zero-length empty string.
- **Associated Data**: The associated data is the handshake hash. This is not encrypted, but the MAC will cover it, allowing Bob to verify it has not been altered during transit.  
- **Key**: Alice will use the one-time key, `temp_k1` generated in Step 4.
- **Nonce**: For Act 1, the nonce is set to `0`.

The result of this function is the message authentication code, `c`.

#### Question: Why is the plaintext field blank? Should Alice be encrypting something?
<details>
  <summary>Answer</summary>

At first, it may be confusing why Alice is not encrypting anything. Isn't the whole point of cryptography to encrypt things? Well, remember Alice's goals for Act 1 are to:
1) Prove to Bob that she knows his public key
2) Communicate this information in a way that Bob can *authenticate* and *verify* Alice's connection

Since `temp_k1` was derived from the ECDH shared secret (which used Bob's static public key), the MAC will only verify correctly if Alice computed the ECDH with Bob's correct public key. When Bob receives this MAC, he will compute his own ECDH using his private key and Alice's ephemeral public key. If they both used the correct keys, they'll derive the same `temp_k1`, and the MAC will verify successfully.

Therefore, Alice doesn't need to encrypt any data - she just needs Bob to validate that the MAC she's sending truly came from her and uses the correct key material. This is exactly what ChaCha20-Poly1305 does! When Alice creates the MAC, she adds the Handshake Hash as Associated Data, and sends the MAC to Bob for him to verify. We'll see how Bob does this verification in just a moment when we review Bob's steps for Act 1.

</details>


### Step 6: Alice Mixes Ciphertext (MAC) Into Hash
Next, Alice will mix the **ciphertext** (the MAC `c` from Step 5) into the **Handshake Hash**.

### Step 7: Alice Sends 50 bytes To Bob
Finally, Alice will send Bob a 50-byte message with the following structure:
- **Byte 1**: The first byte will be the version. As of now, the only valid version is `0`. If the version is anything other than this, Bob will reject the connection.
- **Bytes 2-34**: The next 33 bytes will be Alice's Ephemeral Public Key (in Bitcoin's compressed format). This is not encrypted, as Bob will need to use this to calculate the ECDH shared secret. Since Alice's Ephemeral Public Key is not linked to her Lightning node's identity, transmiting this in plain text does not leak any personal data.
- **Bytes 35-50**: The last 16 bytes are the message authentication code produced by the ChaCha20-Poly1305 encryption algorithm.


## Act 1: Bob's Point-of-View

Next up, let's see how Bob responds to Alice. As we review each step, remember that one of Bob's primary cryptographic goals for Act 1 is to verify the MAC that Alice sent over. If he can do this, then he also implicity verifies that they are using the same Noise variant and that Alice knows his Static Public Key. 

> PRO TIP! The diagram is probably a little hard to see. Try zooming in!

<p align="left" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/noise_act1_bob.png" alt="noise_act1_bob" width="100%" height="auto">
</p>

### Step 1: Bob Receives 50 Bytes From Alice
First, Bob receive the 50 bytes from Alice. Since this is technically the first time he's aware of the connection, he will now execute the pre-handshake steps - creating the handshake hash and mixing in Lightning's Noise variant, the `lightning` prologue, and Bob's Static Public Key.

Bob then reads exactly 50 bytes from the network buffer and parses the message into three components:
- **Version** (1 byte): The handshake version number.
- **Ephemeral Public Key** (33 bytes): Alice's Ephemeral Public Key.
- **Message Authentication Code** (16 bytes): The MAC that Alice created with `temp_k1` and the handshake hash as associated data.

### Step 2: Bob Checks If Version = 0
Before processing the message further, Bob will validate that the version byte equals `0x00`. This ensures both parties are using the same handshake protocol version. If it's not `0x00`, Bob will abort the connection.

### Step 3: Bob Mixes Alice's Ephemeral Key Into His Hash
Bob will then mix Alice's Ephemeral Public Key into his handshake hash. At this point, his hash should exactly match Alice's hash from her Step 2. This should be getting more intuitive! Bob is in the process of catching up and syncing his handshake state with Alice's.

### Step 4: Bob Computes Same ECDH Shared Secret
Now, Bob will take Alice's Ephemeral Public Key and his Static Private Key and compute a shared secret using ECDH. Due to the properties of ECDH, the result will be the exact same shared secret that Alice produced in her Step 3.

### Step 5: Bob Derives Temporary Encryption Key
Next, Bob will derive the same **Temporary Key 1** (`temp_k1`) and **Chaining Key** (`ck`) that Alice did. This is very important, as Bob will need to verify the MAC that Alice sent over, which requires `temp_k1` as an input.

### Step 6: Bob Verifies The MAC
Once Bob has `temp_k1`, the ciphertext (`c`) that Alice sent in her message, and an updated handshake hash (`h`), he can decrypt and verify the MAC using the ChaCha20-Poly1305 cipher.

If the MAC is valid, the decrypt function will succeed and return a zero-length plaintext. If the MAC is invalid, the function will fail with an authentication error, and Bob must immediately terminate the connection.

#### Question: Do you remember why it will return a zero-length plaintext?
<details>
  <summary>Answer</summary>

Remember, Alice is not actually encrypting any plaintext when she originally creates the MAC. Since she leaves the plaintext input blank, Bob will also see a zero-length plaintext when he decrypts the cipher using ChaCha20-Poly1305.

</details>

### Step 7: Bob Mixes Ciphertext Into Hash
Finally, Bob will mix the ciphertext into the hash, synchronizing his handshake hash with Alice's.

## Act 1 Summary
With that, Act 1 is complete! Alice has proved to Bob that she knows his Static Public Key, without publicly revealing any information about herself - both to Bob and the broader network. They have also established a **shared secret**, which will be the basis of their encrypted communication once they complete the handshake process.

Up next, we'll see how Alice and Bob continue the handshake process, and how Alice ultimately reveals her identity to Bob while hiding it from any eavesdroppers.