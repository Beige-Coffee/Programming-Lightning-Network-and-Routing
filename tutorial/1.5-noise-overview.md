# Noise Overview - A Flexible Framework

The Noise Protocol is a flexible **framework** that allows developers to build custom secure communication **protocols**. Noise is called a "framework" because it is meta-system whereby implementors can select from a variety of cryptographic primitives and sub-protocols to create a specific instantiation of the Noise Protocol. For example, Noise can be used for one-way authentication, where a sender simply transmits encrypted information to a recipient, or it can be used for *interactive protocols* such as Lightning, where parties must send encrypted communicated back-and-forth. Furthremore, implemtors have their choice of cryptographic primiatives. For instance, for hash functions, implentors can choose from SHA256, SHA512, or BLAKE2s/BLAKE2b. Likewise, for AEAD Ciphers (encryption), ChaCha20-Poly1305 or AES-256-GCM are available for use. Lightning uses its own specific instantiation of the Noise Protocol, which we'll review shortly.

Another key design choice of the Noise Framework is its emphasis on Diffie-Hellman functions for **authentication**. Usually, in the context of Bitcoin, we think of using signatures for authentication and message integrity. For example, when someone spends a Pay-To-Witness-Public-Key-Hash (P2WPKH), it proves that they know the private key to the public key, and their signature also commits to the transaction data itself. So, why doesn't the Noise Framework also use signatures for authentiation? Well, you can also authenticate identity through Diffie-Hellman, which is more computationally efficient than signatures! When two parties perform ECDH and successfully derive matching shared secrets, it implicitly proves each party knows their private key. These shared secrets can then be used to derive encryption keys that both parties can use to communicate securely, simplifying the entire protocol. It's pretty neat!

The Noise Protocol can be broken into two phases:

1) **Handshake**: The handshake phase used to **authenticate** and establish a **shared secret** between two parties. There are many types of handshake patterns that the Noise Protocol supports, and Lightning uses the `XK` pattern. We'll learn more about these below.
2) **Messaging**: Once the handshake phase is complete and a shared secret has been established, parties can begin to send and receive encrypted communications.

To define the specific Noise Protocol that is being used, you simply concatenate your implementation's choice of handshake pattern, Diffie-Hellman function, cipher function, and hash function - all separated by an underscore. Below is the variant of the Noise protocol that Lightning uses. As you can see, it uses the same Elliptic Curve that bitcoin uses!

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/NoiseProtocol.png" alt="NoiseProtocol" width="100%" height="auto">
</p>
 

## Handshake Patterns
Most of the components of Lightning's Noise Protocol name should be familiar. After all, we revieweved secp256k1, ChaCha20Poly-1305, and SHA256 in the previous section! That said, the handshake pattern has its own unique complexities, so it's worth elaborating on that a little further.

Since the Noise Protocol is meant to be flexible and highly customizable, it support multiple handshake patterns with various levels of authentication - from no authentication to mutual authentication. To idenfify which flavor of handshake is being used, the Noise Protocol defines handshake pattern using two-character names, where the first character describes the status of the **initiator's static key** and the second describes the status of the **responder's static key**

For example, the Lightning network uses the `XK` handshake pattern. In this case, `X` means that the initiator's **static key** (their Lightning node's public key) is *transmitted* during the handshake phase. `K` means that the responder's **static key** is *known* ahead of time. The entirety of the handshake process takes **3 acts**, which we will review shortly! If you've ever opened a new connection on the Lightning Network, this should be familiar to you, as you would have had to specify the public key identity of the node you're connecting to!

Below is a simplified visual depicting the handshake pattern for Lightning nodes. As you can see, Alice - the initator of this connection - knows Bob's static key beforehand. After performing a few cryptographic proofs, which effecitvely allow Alice and Bob to prove their identity, Alice will send Bob an encrypted version of her static key during the final Act. If your bummed that we just glanced over most of the cryptography - don't worry! We'll dig into that next.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/noise_handshake_overview2.png" alt="noise_handshake_overview2" width="100%" height="auto">
</p>

### Three Elliptic Curve Diffie-Hellman Operations In Three Acts
There's a lot going on in the above diagram, so you'd be forgiven if you don't grasp all of it immediatelly! We'll explore each act in detail next, but we'll start with a brief overview.

During the Noise Handshake phase, Alice and Bob will each use the following two sets of keys:
- **Static Key Pair**: This is their Lightning node's identity. The public key is advertised on the Lightning Network, and the private key performs actions such as signing gossip messages and authenticating themselves in communication.
- **Ephemeral Key Pair**: Alice and Bob will create an ephemeral key pair *for each communication instance*. For example, when Alice attempts to connect to Bob, she will generate a new ephemeral key pair. If their connection is dropped and they have to reconnet, they will both generate an entirely *new* ephemeral key pair. This ensures that their resulting encryption keys are new for each communication session, reducing security vulnerabilities whereby an attacker who obtains an encryption key from an old state would be able to decrypt all messages between Alice and Bob.

Lightning's Noise **handshake** invovles **three acts**. In each act, a unique Diffie-Helman operation is performed between a different set of keys.
> NOTE: Below, you'll see patterns such as `es`, `ee`, `se`. This is meant to be **ECDH Notation:**, whereby the first letter is the initiator's key, the second is the responder's key.
- **Act 1**: In the first act, Alice will compute `es`, an ECDH operation between her ephemeral private key and Bob's static public key. Bob will perform the same ECDH operation, but with his static private key and Alice's ephemeral public key, which she sends in Act 1. This proves to Bob that Alice knows his identity.
- **Act 2**: In the second act, Bob will compute `ee`, an ECDH operation between his ephemeral private key and Alice's ephemeral public key. Once he sends his ephemeral public key to Alice, she will be able to derive `ee` as well. At this point, they have both contributed randomness to their shared secret. Since Bob and Alice will delete their ephemeral keys after the handshake, an attacker would not be able to compute `ee` without knowledge of either ephemeral private key. This provides **forward secrecy**, ensuring that channel communicatin stays secure even if a key is compromised.
- **Act 3**: Finally, in act three, Alice will compute `se`, an ECDH operation between her static private key and Bob's ephemeral public key. She will then send an ecrypted version of her static public key. Once Bob decrypts it, he will be able to compute `se` as well and authenticate Alice's identity.

#### Question: Why is forward secrecy not established until Act 2?
<details>
  <summary>Answer</summary>

Forward secrecy means that if an attacker gained access to Alice or Bob's static private key, they could not decrypt all past communication between them. To see why this is not achieved in Act 1, consider the following scenario.

If Bob's static private key were compromised, an attacker could compute `es = ECDH(bob_static_private, alice_ephemeral_public)`. Since Alice's ephemeral public key was transmitted in Act 1, the attacker can derive all keys based on `es` and decrypt that traffic.

Forward secrecy is established in Act 2 when both parties compute `ee = ECDH(alice_ephemeral_private, bob_ephemeral_private)`, since both ephemeral private keys are deleted after the handshake completes. Even if both static keys are later compromised, the attacker only has the ephemeral *public* keys and cannot compute `ee` without at least one ephemeral *private* key. 

</details>


This handshake patter, known as **XK**, is one of many that the Noise Protocol supports. If you'd like to learn which other patterns are supported, click the dropdown below.

<details>
  <summary>Handshake patterns</summary>

The first table lists each character and its meaning for the **initiator** of a connection, and the second table defines the character and meaning for the **responder** of a channel.

### Initiator's Static Key (First Character)

| Character | Meaning | Description |
|-----------|---------|-------------|
| **N** | **N**o static key | Initiator has no static key (anonymous to responder) |
| **K** | Static key **K**nown | Initiator's static key is already known by responder before handshake |
| **X** | Static key **X**mitted | Initiator transmits their static key during handshake |
| **I** | **I**mmediately transmitted | Initiator sends static key immediately in first message, with reduced/no identity hiding |

### Responder's Static Key (Second Character)

| Character | Meaning | Description |
|-----------|---------|-------------|
| **N** | **N**o static key | Responder has no static key (anonymous to initiator) |
| **K** | Static key **K**nown | Responder's static key is already known by initiator before handshake |
| **X** | Static key **X**mitted | Responder transmits their static key during handshake |

</details>

